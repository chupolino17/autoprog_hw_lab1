# Пример реализации DSL

## Что делаем

Создаем свой "малый" язык программирования для решения определенного круга задач. Такие языки называют еще Domain Specific Language (DSL). Есть более строгое определение, см. лекции.

## Подготовка

Нам потребуется
  - python3
  - textX (``pip install textX``)
  - graphviz (проверить наличие, желательно)

## Задача 1

Сделаем Hello world! Из документации к [``textX``](http://textx.github.io/textX/stable/tutorials/hello_world/).
Хотим получить приветствия на выходе для каждого участника. Примерно так:

```
Hello World!
Hello Universe!
```

1. Изучаем, как создавать [грамматику](http://textx.github.io/textX/stable/grammar/).
2. Смотрим [пример грамматики](./hello.tx)
3. Построим диаграмму метамодели (модели созданного языка) из грамматики:

```
$ textx generate hello.tx --target dot
$ dot -Tpng hello.dot -o hello.png
```

4. Теперь пишем пример "программы" на нашем DSL. [Текст здесь](./example.hello)
5. И нам нужен интерпретатор модели, который сможет ее выполнить. Он простой, делаем на python, код есть [здесь](./hello.py). Обратите внимание на импорты из ``textx`` и как загружать модель.
6. Далее запускаем интерпетатор

```
$ python hello.py
```

## Задача 2

DSL для управления роботом Karel. Управляет небольшим роботом на плоской доске в клетку со стенками и маяками. Назван в честь автора пьесы про андроидов из 1920-х годов.

Мы будем использовать реализацию самого робота на python, найденную [здесь](https://github.com/xsebek/karel) и исправленную уже в [проекте](./karel_robot)

Создадим что-то похожее на вот это [описание](http://mormegil.wz.cz/prog/karel/prog_doc.htm):

### Задание 1

Начнем с последовательного исполнения команд ``move``, ``turn``, ``exit``, ``beeper``. Пример грамматики [здесь](./karel-plain.tx).

 > Какие команды определены, есть ли у них параметры?

  Команды без параметров:
  * `move`
  * `exit`

  Команды с параметрами:
  * `turn` (arg = where)
  * `beeper` (arg = action)

 > Какие ключевые слова есть в языке?

`begin`, `end`, `exit`, `move`, `turn`, `left`, `right`, `beeper`, `pick`, `put`

 > Напишите программу, которая передвигает робота на 2 клетки вперед и на 2 направо

 [код программы](task2/maze-2move-2right.karel)

 > Какие соглашения используются для токенизации?

  `begin` и `end` - ограничивают блок программы,
  между `begin` и `end` - остальные команды.

### Задание 2

Сделаем интерпретатор. Проще всего сделать отдельный класс для него, экземпляры которого будут хранить состояние исполнения программы. В нашем случае ``karel_robot`` хранит состояние глобально, поэтому это не существенно.

Реализуйте методы выполнения программы на DSL ``interpret(self, model)`` и j,обработки отдельной команды ``process_command(self, c)`` в классе интерпретатора.

Для использования визуализации и уже готовых команд импортируйте все из ``karel_robot.run``. [Пример реализации.](./karel_plain.py)

 > Какой способ реализации мы здесь применяем?

Интерпретатор выполняет наборы команды, которые явно указаны.

 > Подойдут ли здесь какие-либо паттерны проектирования?

Интерпретатор.
 > Как вы проверяете, что обрабатываемый узел модели имеет определенный тип из метамодели языка?

 Узлы модели на конкретном уровне в AST имеют определнной тип.

Проверьте, что все работает как надо, запустив интерпретатор. Должна появится текстовая картинка, по которой ходит робот.

```
$ python karel_plain.py
```

### Задание 3

Добавим в наш язык логические выражения для проверки положения и направления робота: ``north``, ``south``, ``east``, ``west``; определения есть ли стена, маяк или сокровище напротив ``front_is_blocked``, ``is_beeper``, ``front_is_treasure``; а также логические операции ``not``, ``or``, ``and``.

----
 > Как указать приоритет ``and`` над ``or``? И ``not`` над ними обоими?

 Посредством правильных скобочных выражений с помощью `(` и `)`.

----
Теперь добавим условные конструкции ``if-then-else`` и ``while``. Можно еще добавить повторение ``n`` раз. Пример реализации [здесь](./karel-control.tx)

---

 > Выясните, в чем состоит проблема dangling-else, как она решается в нашем случае в textx?

`dangling-else problem` - это проблема неоднозначности разбора, когда имеется вложенный `if` и следующий за ним `else` - неоднозначность к `if` какого уровня применяется `else`.

 В нашем случае, границы ветвления это `if ... then ... end`. Поэтому можно однозначно определить к `if` какого уровня вложенности применяется `else`.

 > Обратите внимание, что кроме команд теперь есть и выражения, которые возвращают логическое значение и не являются командами. Как они добавлены в грамматику языка?

 При помощи ключевых слов интерпретатора таких как `front_is_blocked`, `is_beeper`, `front_is_treasure`, ``north``, ``south``, ``east``, ``west``, а также их комбинации через `not`, `or`, `and`.

 > Добавьте цикл из ``n`` повторений самостоятельно

---

Аналогично, нужно добавить реализацию в интерпретатор. Добавим метод ``process_expression(self, e)`` и расширим обработку команд. Один из вариантов [доработки](./karel_control.py).

---
 > Программа теперь состоит из команды и выражений. Как бы вы реализовали их обработку?

 Также как и в представленной реализации.

 ---

Если все сделано верно, теперь уже можем написать программу обхода лабиринта в поиска сокровищ для произвольного ограниченного стенами лабиринта. Пример программы [здесь](./maze.karel). Не забудьте остановить программу по нахождении сокровища.

## Задача 3

Теперь посложнее. Нужно добавить подрограммы и пользовательские функции. Сигнатура должна описывать передаваемые параметры - логические выражения. Еще будет полезна отдельная команда на вызов.

---
 > Есть синтаксис pascal-like, c-like и python-like. Какой вам ближе?

 > Продумайте, как обозначить возвращаемое значение из функции.

Например, через `return` или другое ранее незарезервированное ключевое слово.

---

Реализуем в интерпертаторе. Сохранять место текущего исполнения можно вызывая подпрограмму в текущем месте в самом язке программирования интерпертатора. Вот как [здесь](./karel_structured.py)

 > Как лучше передавать параметры - по значению или по ссылке?

 Для нашего интерпретатора достаточно передачи по значению, так как нет каких-то комплексных типов и чего-то более сложного.

 > Нужен ли стек для реализации подпрограмм? Узнайте, что такое stack frames.Сравните с тем, что уже знаете про область видимости переменных

Да нужен. Более того, помимо стека нужны и stack frames (однозначно определенная область стека, где передаются аргументы вызываемой процедуры, сохраняется место/инструкция на которую возвращаемся из вызванной процедуры обратно в вызывающую, stack frame служит временным местом хранения промежуточный переменных, позволяет разграничивать области видимости переменных внутри разных процедур). Очевидно, что в рамках вызова одной процедуры можно обойтись одним стек-фреймом, чтобы ограничивать область видимости переменных, например, нельзя обращаться к переменным, объявленным внутри цикла, извне самого цикла

---

Еще стоит добавить команду прерывания цикла ``break``. Она должна приводить к выходу из текущего цикла внутри одной подпрограммы, если такой цикл есть. Приммер реализации без нарушения структуры кода см. [там же](./karel_structured.py).

  > Как бы вы реализовали ``goto``? В ранних вариантах Бейсика можно было выходить как за пределы структурного блока, так и за пределы подпрограмм, чем это грозит?

Начнем с ответа на бейсик, очевидно, это грозит в зависимости от умности шедлелера ос, где вы запускаетесь, но в первую очередь, при выходе за блок, это очевидно ub. Ни говоря о том, если вы запускаетесь на чем то не очень умном, то потенциально можно украсть и/или испортить чужой код в памяти.

Отвечая на вопрос про `goto`, скажу, что не знаю ни одного примера реализации подобной функции ни в одном интепретируемом языке. Ибо мы читаем код по строчкам, то нам видимо сначала нужен какой-то препроцессинг.

  > Обратите внимание, что мы пока не определяли никакие хранимые данные. ТО есть все данные хранятся на поле в клетку. Если нужно, можно ставить маяки. Как считаете, нужны ли переменные в программе и зачем?

  Т.к. дополнительно не указаны предвариательные требования, а набор инструкций ограничен, то можем считать, что пока хранимые данные не нужны.

> Реализуйте программу поиска сокровищ в лабиринте с применением добавленных конструкций языка. Примера в этот раз нет.

Дабы не копипастить лишний раз. За интерпретатор был взят [karel_structed](./karel_structured.py) с подменненой моделью работа.
Вот код решения с [BFS](task3/maze-solver.karel) на борту.
